<h1>Feature: Step definitions parameters parsing</h1>
<p>Step parameters often enable the reuse of steps,
which can reduce the amount of code required.
This methodology allows for the same step
to be used multiple times within a single scenario,
but with different arguments.
There are an multiple step parameter parsers available for your use.</p>
<h2>Rule: Step definitions parameters parsing</h2>
<h3>Background:</h3>
<ul>
<li>Given File &quot;Parametrized.feature&quot; with content:
<pre><code class="language-gherkin">Feature: StepHandler arguments
  Scenario: Every step takes a parameter with the same name
    Given I have a wallet
    Given I have 6 Euro
    When I lose 3 Euro
    And I pay 2 Euro
    Then I should have 1 Euro
    # In my dream...
    And I should have 999999 Euro
</code></pre>
</li>
</ul>
<h3>Example: Heuristic parser guesses a type and builds particular parser to be applied</h3>
<pre><code>  Tries to select right parser between string, cucumber_expression, cfparse and re.
  Any object that supports `__str__` interface and does not support parser interface
  will be wrapped with this parser
</code></pre>
<ul>
<li>Given File &quot;conftest.py&quot; with content:
<pre><code class="language-python">import pytest
from pytest_bdd import given, when, then

@pytest.fixture
def values():
    return [6, 3, 2, 1, 999999]

# string parser
@given(&quot;I have a wallet&quot;, param_defaults={'wallet': 'wallet'})
def i_have_wallet(wallet):
    assert wallet == 'wallet'

# cucumber expressions parser
@given(&quot;I have {int} Euro&quot;,
  anonymous_group_names=('euro',),
  converters=dict(euro=int)
)
def i_have(euro, values):
    assert euro == values.pop(0)

# parse parser
@when(
  &quot;I pay {} Euro&quot;,
  anonymous_group_names=('euro',),
  converters=dict(euro=int)
)
def i_pay(euro, values):
    assert euro == values.pop(0)

# cfparse parser
@when(&quot;I lose {euro:d} Euro&quot;, converters=dict(euro=int))
def i_lose(euro, values):
    assert euro == values.pop(0)

# regular expression parser
@then(
  r&quot;I should have (\d+) Euro&quot;,
  anonymous_group_names=('euro',),
  converters=dict(euro=int)
)
def i_should_have(euro, values):
    assert euro == values.pop(0)
</code></pre>
</li>
<li>When run pytest</li>
<li>Then pytest outcome must contain tests with statuses:
<table>
<thead>
<tr>
<th>passed</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3>Example: by &quot;parse&quot;</h3>
<pre><code>  http://pypi.python.org/pypi/parse

  Provides a simple parser that replaces regular expressions for
  step parameters with a readable syntax like ``{param:Type}``.
  The syntax is inspired by the Python builtin ``string.format()``
  function.
  Step parameters must use the named fields syntax of pypi_parse_
  in step definitions. The named fields are extracted,
  optionally type converted and then used as step function arguments.
  Supports type conversions by using type converters passed via `extra_types`
</code></pre>
<ul>
<li>Given File &quot;conftest.py&quot; with content:
<pre><code class="language-python">import pytest
from pytest_bdd import given, when, then
from parse import Parser as parse

@pytest.fixture
def values():
    return [6, 3, 2, 1, 999999]

@given(parse(&quot;I have a wallet&quot;), param_defaults={'wallet': 'wallet'})
def i_have_wallet(wallet):
    assert wallet == 'wallet'

@given(parse(&quot;I have {euro:g} Euro&quot;))
def i_have(euro, values):
    assert euro == values.pop(0)

@when(parse(&quot;I pay {euro:d} Euro&quot;))
def i_pay(euro, values):
    assert euro == values.pop(0)

@when(
  parse(&quot;I lose {} Euro&quot;),
  anonymous_group_names=('euro',),
  converters=dict(euro=int)
)
def i_pay(euro, values):
    assert euro == values.pop(0)

@then(
  parse(r&quot;I should have {:d} Euro&quot;),
  anonymous_group_names=('euro',),
  converters=dict(euro=int)
)
def i_should_have(euro, values):
    assert euro == values.pop(0)
</code></pre>
</li>
<li>When run pytest</li>
<li>Then pytest outcome must contain tests with statuses:
<table>
<thead>
<tr>
<th>passed</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3>Example: by &quot;cfparse&quot;</h3>
<pre><code>  http://pypi.python.org/pypi/parse_type

  Provides an extended parser with &quot;Cardinality Field&quot; (CF) support.
  Automatically creates missing type converters for related cardinality
  as long as a type converter for cardinality=1 is provided.
  Supports parse expressions like:
  ``{values:Type+}`` (cardinality=1..N, many)
  ``{values:Type*}`` (cardinality=0..N, many0)
  ``{value:Type?}``  (cardinality=0..1, optional)
  Supports type conversions (as above).
</code></pre>
<ul>
<li>Given File &quot;conftest.py&quot; with content:
<pre><code class="language-python">import pytest
from pytest_bdd import given, when, then
from parse_type.cfparse import Parser as parse

@pytest.fixture
def values():
    return [6, 3, 2, 1, 999999]

@given(parse(&quot;I have a wallet&quot;), param_defaults={'wallet': 'wallet'})
def i_have_wallet(wallet):
    assert wallet == 'wallet'

@given(parse(&quot;I have {euro:Number} Euro&quot;, extra_types=dict(Number=int)))
def i_have(euro, values):
    assert euro == values.pop(0)

@when(parse(&quot;I pay {euro:d} Euro&quot;))
def i_pay(euro, values):
    assert euro == values.pop(0)

@when(
  parse(&quot;I lose {} Euro&quot;),
  anonymous_group_names=('euro',),
  converters=dict(euro=int)
)
def i_pay(euro, values):
    assert euro == values.pop(0)

@then(
  parse(r&quot;I should have {:d} Euro&quot;),
  anonymous_group_names=('euro',),
  converters=dict(euro=int)
)
def i_should_have(euro, values):
    assert euro == values.pop(0)
</code></pre>
</li>
<li>When run pytest</li>
<li>Then pytest outcome must contain tests with statuses:
<table>
<thead>
<tr>
<th>passed</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3>Example: by &quot;cucumber-expressions&quot;</h3>
<pre><code>  https://github.com/cucumber/cucumber-expressions
  Cucumber Expressions is an alternative to Regular Expressions
  with a more intuitive syntax.
</code></pre>
<ul>
<li>And File &quot;conftest.py&quot; with content:
<pre><code class="language-python">from functools import partial
import pytest
from pytest_bdd import given, when, then
from cucumber_expressions.parameter_type_registry import ParameterTypeRegistry
from cucumber_expressions.expression import CucumberExpression

parse = partial(
  CucumberExpression,
  parameter_type_registry = ParameterTypeRegistry()
)

@pytest.fixture
def values():
    return [6, 3, 2, 1, 999999]

@given(parse(&quot;I have a wallet&quot;), param_defaults={'wallet': 'wallet'})
def i_have_wallet(wallet):
    assert wallet == 'wallet'

@given(
  parse(&quot;I have {int} Euro&quot;),
  anonymous_group_names=('euro',),
  converters=dict(euro=int)
)
def i_have(euro, values):
    assert euro == values.pop(0)

@when(
  parse(&quot;I pay {} Euro&quot;),
  anonymous_group_names=('euro',),
  converters=dict(euro=int)
)
def i_pay(euro, values, request):
    assert euro == values.pop(0)

@when(
  parse(r&quot;I lose {int} Dollar/Euro(s)&quot;),
  anonymous_group_names=('euro',),
  converters=dict(euro=int)
)
def i_lose(euro, values):
    assert euro == values.pop(0)

@then(
  parse(&quot;I should have {int} Euro&quot;),
  anonymous_group_names=('euro',),
  converters=dict(euro=int)
)
def i_should_have(euro, values):
    assert euro == values.pop(0)
</code></pre>
</li>
<li>When run pytest</li>
<li>Then pytest outcome must contain tests with statuses:
<table>
<thead>
<tr>
<th>passed</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3>Example: by &quot;cucumber-regular-expressions&quot;</h3>
<pre><code>https://github.com/cucumber/cucumber-expressions

Cucumber Expressions is an alternative
to Regular Expressions with a more intuitive syntax.
</code></pre>
<ul>
<li>And File &quot;conftest.py&quot; with content:
<pre><code class="language-python">import pytest
from pytest_bdd import given, when, then
from functools import partial

from cucumber_expressions.parameter_type_registry import ParameterTypeRegistry
from cucumber_expressions.regular_expression import (
  RegularExpression as CucumberRegularExpression
)

parse = partial(
  CucumberRegularExpression,
  parameter_type_registry = ParameterTypeRegistry()
)

@pytest.fixture
def values():
    return [6, 3, 2, 1, 999999]

@given(parse(&quot;I have a wallet&quot;), param_defaults={'wallet': 'wallet'})
def i_have_wallet(wallet):
    assert wallet == 'wallet'

@given(
  parse(r&quot;I have (\d+) Euro&quot;),
  anonymous_group_names=('euro',),
  converters=dict(euro=int)
)
def i_have(euro, values):
    assert euro == values.pop(0)

@when(
  parse(&quot;I pay (.*) Euro&quot;),
  anonymous_group_names=('euro',),
  converters=dict(euro=int)
)
def i_pay(euro, values, request):
    assert euro == values.pop(0)

@when(
  parse(r&quot;I lose (.+) Euro&quot;),
  anonymous_group_names=('euro',),
  converters=dict(euro=int)
)
def i_lose(euro, values):
    assert euro == values.pop(0)

@then(
  parse(r&quot;I should have (\d+) Euro&quot;),
  anonymous_group_names=('euro',),
  converters=dict(euro=int)
)
def i_should_have(euro, values):
    assert euro == values.pop(0)
</code></pre>
</li>
<li>When run pytest</li>
<li>Then pytest outcome must contain tests with statuses:
<table>
<thead>
<tr>
<th>passed</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3>Example: by &quot;regular-expressions&quot;</h3>
<pre><code>This uses full regular expressions to parse the clause text. You will
need to use named groups &quot;(?P&lt;name&gt;...)&quot; to define the variables pulled
from the text and passed to your &quot;step()&quot; function.
Type conversion can only be done via &quot;converters&quot; step decorator
argument (see example in according feature).
</code></pre>
<ul>
<li>Given File &quot;conftest.py&quot; with content:
<pre><code class="language-python">import pytest
from pytest_bdd import given, when, then
from re import compile as parse

@pytest.fixture
def values():
    return [6, 3, 2, 1, 999999]

@given(parse(&quot;I have a wallet&quot;), param_defaults={'wallet': 'wallet'})
def i_have_wallet(wallet):
    assert wallet == 'wallet'

@given(parse(r&quot;I have (?P&lt;euro&gt;\d+) Euro&quot;), converters=dict(euro=int))
def i_have(euro, values):
    assert euro == values.pop(0)

@when(
  parse(r&quot;I pay (\d+) Euro&quot;),
  anonymous_group_names=('euro',),
  converters=dict(euro=int)
)
def i_pay(euro, values):
    assert euro == values.pop(0)

@when(parse(r&quot;I lose (.+) Euro&quot;),
  anonymous_group_names=('euro',),
  converters=dict(euro=int)
)
def i_lose(euro, values):
    assert euro == values.pop(0)

@then(parse(r&quot;I should have (?P&lt;euro&gt;\d+) Euro&quot;), converters=dict(euro=int))
def i_should_have(euro, values):
    assert euro == values.pop(0)
</code></pre>
</li>
<li>When run pytest</li>
<li>Then pytest outcome must contain tests with statuses:
<table>
<thead>
<tr>
<th>passed</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
</tr>
</tbody>
</table>
</li>
</ul>
